import lief
import argparse


def map_syscall_to_winapi():
    """parse local ntdll to map syscall numbers to their Nt function names"""
    syscalls = {}
    ntdll = lief.parse(r"C:\Windows\SysWOW64\ntdll.dll")  # use 32-bit ntdll as x86 Nt exports are a superset of x64 Nt exports
    for export in ntdll.exported_functions:
        if export.name.startswith("Zw"):
            syscalls["Nt" + export.name[2:]] = export.address  # replace `Zw` w/ `Nt` to be consistent w/ map_winapi_to_args()

    # sort syscalls by addr
    syscalls = [x[0] for x in sorted(syscalls.items(), key=lambda x: x[1])]
    return {v: k for v, k in enumerate(syscalls)}


def process_syscalls(tag_file):
    """replace the syscall numbers & arguments in Tinytracer's output w/ their actual Nt function & argument names"""
    syscall_to_winapi = map_syscall_to_winapi()
    with open(r"declarations.out", "r") as f:
        winapi_to_args = eval(f.read())

    with open(tag_file, "r") as g:
        lines = g.readlines()
        i = 0
        while i < len(lines):

            # replace syscall number w/ function name
            if "SYSCALL" in lines[i]:
                syscall_pos = lines[i].split(":")[1].split("\n")[0]
                syscall = int(syscall_pos.split("(")[0], 16)
                if syscall in syscall_to_winapi:
                    winapi = syscall_to_winapi[syscall]
                    lines[i] = lines[i].replace(syscall_pos, winapi)
                    i += 1
                    if not lines[i].startswith(f"\t"):
                        i += 1 # skip fuction's name

                    # add argument names of function
                    remove = False  # used to handle Nt fxs that are undeclared
                    for c in range(10):  # Tinytracer only prints a maximum of 10 arguments
                        if lines[i].startswith(f"\tArg[{c}]"):
                            try:
                                lines[i] = lines[i].replace(f"Arg[{c}]", winapi_to_args[winapi][c])
                                remove = True
                                i += 1
                            except:
                                if remove:
                                    lines.pop(i)  # removes non-existent argument
            i += 1

    with open(f"{tag_file}.out", "w") as h:
        h.write("".join(lines))
        print(f"Output written to {tag_file}.out")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-file", metavar="<filename>", type=str, required=True, help="Takes in a .tag file generated by Tinytracer")
    args = parser.parse_args()
    process_syscalls(args.file)
